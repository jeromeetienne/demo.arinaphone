<!DOCTYPE html>
<!-- include three.js -->
<script src='vendor/three.js/build/three.js'></script>

<!-- include js-aruco -->
<script src="vendor/js-aruco/svd.js"></script> 
<script src="vendor/js-aruco/posit1.js"></script> 
<script src="vendor/js-aruco/cv.js"></script> 
<script src="vendor/js-aruco/aruco.js"></script> 

<body style='margin: 0px; overflow: hidden; text-align:center;'><script>
	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	// init renderer
	var renderer	= new THREE.WebGLRenderer({
		antialias	: true,
		alpha: true,
	});
	renderer.setClearColor(new THREE.Color('black'), 0)
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	// array of functions for the rendering loop
	var onRenderFcts= [];

	// init scene and camera
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
	camera.position.z = 2;

	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
	//////////////////////////////////////////////////////////////////////////////////

	// add a torus	
	var geometry = new THREE.SphereGeometry(0.5, 15, 15, Math.PI)
  var material = new THREE.MeshBasicMaterial( {
		map: THREE.ImageUtils.loadTexture("images/earth.jpg")
	})
  var mesh = new THREE.Mesh(geometry, material);
	scene.add( mesh );
	
	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// handle window resize
	window.addEventListener('resize', function(){
		renderer.setSize( window.innerWidth, window.innerHeight )
		camera.aspect	= window.innerWidth / window.innerHeight
		camera.updateProjectionMatrix()		
	}, false)

	// render the scene
	onRenderFcts.push(function(){
		renderer.render( scene, camera );		
	})
	
	// run the rendering loop
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
	
	//////////////////////////////////////////////////////////////////////////////////
	//		shim party
	//////////////////////////////////////////////////////////////////////////////////
	
  // shim
  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  window.URL = window.URL || window.webkitURL;

	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////
	
	var videoElement = document.createElement('video')
	document.body.appendChild(videoElement)
	videoElement.style.position = 'absolute'
	videoElement.style.top = '0px'
	videoElement.style.left = '0px'
	videoElement.style.width = '100%'
	videoElement.style.height = '100%'
	videoElement.style.zIndex = -1;


	
									
	var constraints = {video:true}
	navigator.getUserMedia(constraints, function (stream){
		videoElement.src = URL.createObjectURL(stream);
		videoElement.play();
	}, function(error){
    console.log("An error occured! ");
    console.dir(error)
	});
	
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////
	
	var canvasElement = document.createElement('canvas')
	canvasElement.width	= 320
	canvasElement.height	= 240
	// document.body.appendChild(canvasElement)
	canvasElement.style.position = 'absolute'
	canvasElement.style.top = '0px'
	canvasElement.style.left = '0px'
	canvasElement.style.opacity = 0.2

	var context = canvasElement.getContext("2d");

	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////
  
	var detector = new AR.Detector();
	var modelSize = 35.0; // millimeter
  var posit = new POS.Posit(modelSize, canvasElement.width);
	
	onRenderFcts.push(function(){
		// if no new image for videoElement do nothing
    if (videoElement.readyState !== videoElement.HAVE_ENOUGH_DATA) return

		// get imageData from videoElement
  	context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
  	var imageData = context.getImageData(0, 0, canvasElement.width, canvasElement.height);
		
		// detect markers
		var markers = detector.detect(imageData);
		// display markers on canvas for debug
		// drawCorners(canvasElement, markers)
			
		// if no marker got detected
    if (markers.length  ===  0) return
		
    var corners = markers[0].corners;
		// convert corners coordinate - not sure why
    for (var i = 0; i < corners.length; ++ i){
      var corner = corners[i];
      corner.x = corner.x - (canvasElement.width / 2);
      corner.y = (canvasElement.height / 2) - corner.y;
    }

    // determine the pose
    var pose = posit.pose(corners);
		
    // update mesh with post
    updateObject(mesh, pose.bestRotation, pose.bestTranslation);
  };
	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * draw corners on a canvas - useful to debug
	 * 
	 * @param {Object[]} markers - array of found markers
	 */
  function drawCorners(markers, canvasElement){
		var context = canvasElement.getContext("2d");
    var corners, corner, i, j;
  
    context.lineWidth = 3;

    for (i = 0; i < markers.length; ++ i){
      corners = markers[i].corners;
      
      context.strokeStyle = "red";
      context.beginPath();
      
      for (j = 0; j < corners.length; ++ j){
        corner = corners[j];
        context.moveTo(corner.x, corner.y);
        corner = corners[(j + 1) % corners.length];
        context.lineTo(corner.x, corner.y);
      }

      context.stroke();
      context.closePath();
      
      context.strokeStyle = "green";
      context.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
    }
  };
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////
  function updateObject(object3d, rotation, translation){
    object3d.scale.x = modelSize;
    object3d.scale.y = modelSize;
    object3d.scale.z = modelSize;
    
    object3d.rotation.x = -Math.asin(-rotation[1][2]);
    object3d.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);
    object3d.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);

    object3d.position.x = translation[0];
    object3d.position.y = translation[1];
    object3d.position.z = -translation[2];
  };
</script></body>
